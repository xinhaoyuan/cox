#include <runtime/page.h>
#include <runtime/io.h>
#include <mach.h>

struct area_s
{
	size_t start;
	size_t end;

	int free;
};

struct area_node_s
{
	int rank;
	struct area_node_s *parent, *left, *right;

	size_t start, end;
	size_t max_free;
	
	struct area_s area;
};

		n->end   = n->area.end;										\
	} while (0);

#define __RBT_SwapNodeContent(a,b) do {			\
		struct area_s area = (a)->area;			\
		(a)->area = (b)->area;					\
		(b)->area = area;						\
	} while (0)
#define __RBT_GetRank(n) ((n) == __RBT_NodeNull ? 1 : (n)->rank)
#define __RBT_SetRank(n,r)  do { (n)->rank = (r); } while (0)
#define __RBT_CompareKey(k,n) ((k) == (n)->area.start ? 0 : ((k) < (n)->area.start ? -1 : 1))
#define __RBT_CompareNode(n1,n2) ((n1)->area.start == (n2)->area.start ? 0 : ((n1)->area.start < (n2)->area.start ? -1 : 1))
#define __RBT_AcquireParentAndDir(n,p,d)					\
	 {														\
		  (p) = (n)->parent;								\
		  (d) = (p) == __RBT_NodeNull ? DIR_ROOT :			\
			   ((p)->left == (n) ? DIR_LEFT : DIR_RIGHT);	\
	 }
#define __RBT_SetRoot(n) do { n->parent = NULL; } while (0)
#define __RBT_GetLeftChild(n)    ((n)->left)
#define __RBT_GetRightChild(n)   ((n)->right)
#define __RBT_SetLeftChild(n,c)  do { (n)->left = (c); if ((c) != __RBT_NodeNull) (c)->parent = (n); area_update_inv(n); } while (0)
#define __RBT_SetRightChild(n,c) do { (n)->right = (c); if ((c) != __RBT_NodeNull) (c)->parent = (n); area_update_inv(n); } while (0)
#define __RBT_SetChildren(n,l,r) do { (n)->left = (l); if ((l) != __RBT_NodeNull) (l)->parent = (n); (n)->right = (r); if ((r) != __RBT_NodeNull) (r)->parent = (n); area_update_inv(n); } while (0)
#define __RBT_SetLeftChildFromRightChild(n,p)							\
	do { (n)->left = (p)->right; if ((n)->left) (n)->left->parent = (n); area_update_inv(n); } while (0)
#define __RBT_SetRightChildFromLeftChild(n,p)							\
	do { (n)->right = (p)->left; if ((n)->right) (n)->right->parent = (n); area_update_inv(n); } while (0)
#define __RBT_ThrowException(msg)				\
	do { } while (0)
#define __RBT_NeedFixUp 1

static void area_update_inv(area_node_t area);

#include <algo/rbt_algo.h>

static void
area_update_inv(area_node_t node)
{
	node->max_free = 0;
	if (node->left)
	{
		node->start = node->left->start;
		if (node->left->max_free > node->max_free)
			node->max_free = node->left->max_free;
		if (node->area.start - node->left->end > node->max_free)
			node->max_free = node->area.start - node->left->end;
	}
	else node->start = node->area.start;
	if (node->right)
	{
		node->end = node->right->end;
		if (node->right->max_free > node->max_free)
			node->max_free = node->right->max_free;
		if (node->right->start - node->area.end > node->max_free)
			node->max_free = node->right->start - node->area.end;
	}
	else node->end = node->area.end;
}

static void *
__palloc(size_t num)
{
	if (num == 0) return NULL;
	area_node_t node = __root;

	area_node_t n = NULL;
   
	if (node == NULL)
	{
		n = __area_node_new();
		n->area.start = 0;
		n->area.end   = num;
	}
	else if (node->max_free < num)
	{
		if (node->start >= num)
		{
			n = __area_node_new();
			n->area.start = 0;
			n->area.end   = num;
		}
		else if (((__fend - __start) >> __PGSHIFT) - node->end >= num)
		{
			n = __area_node_new();
			n->area.start = node->end;
			n->area.end   = n->area.start + num;
		}
		else return NULL;
	}

	while (n == NULL)
	{
		if (node->left)
		{
			if (node->left->max_free >= num)
			{
				node = node->left;
				continue;
			}
			else if (node->area.start - node->left->end >= num)
			{
				n = __area_node_new();
				n->area.start = node->left->end;
				n->area.end   = n->area.start + num;
				break;
			}
		}

		if (node->right)
		{
			if (node->right->max_free >= num)
			{
				node = node->right;
				continue;
			}
			else if (node->right->start - node->area.end >= num)
			{
				n = __area_node_new();
				n->area.start = node->area.end;
				n->area.end   = n->area.start + num;
				break;
			}
		}

		/* should not happen */
		return NULL;
	}

	__root = __RBT_Insert(node, n);

	return (void *)(__start + (n->area.start << __PGSHIFT));
}

static int
__pfree(void *addr)
{
	area_node_t node = __root;
	size_t start = ((uintptr_t)addr - __start) >> __PGSHIFT;
	
	while (1)
	{
		if (node == NULL) break;

		if (node->area.start <= start && node->area.end > start) break;
		if (node->area.start > start)
			node = node->left;
		else node = node->right;
	}

	if (node == NULL || node->area.start != start) return -1;
	
	__root = __RBT_Remove(node, &node, start);
	__area_node_free(node);

	return 0;
}
