[USER MODEL INTRO]

COX is designed to provide minimalistic user model. In COX
environment, user code is deployed on a segment of address space. The
interval could be suggested by user, while would finally decided by
kernel. There is no page sharing semantic in user model (unless between
different thread in a process). But the page aligned transfers would
be accelerated by hardware mechanism.

[MEMORY MODEL]

No memory map (only MMIO maps for driver node). No memory sharing
between processes. No fork.

[SYSCALL and IO]

COX user I/O is based on buffered request mechanism, which does not
depend on syscalls anymore. When issue an I/O, user app just writes a
I/O request in the I/O buffer. Notification would come when request
finished. User can also poll the request status by customized
scheduling. The only active syscall is called when the user is blocked
by I/O requests. Thus yield the cpu clock and wait for replies.

[SOCKETS]

I/Os are mainly the socket operations. All IPCs are through the
sockets, local IPCs would be optimized by hardware and
kernel. Currently the network software stack are built in kernel,
leaving drivers in userspace.
