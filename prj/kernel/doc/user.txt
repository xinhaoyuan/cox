[USER MODEL INTRO]

COX is designed to provide minimalistic user model. In COX
environment, user code is deployed on a segment of address space. The
interval could be suggested by user, while would finally decided by
kernel. There is no page sharing semantic in user model (unless between
different thread in a process). But the page aligned transfers would
be accelerated by hardware mechanism.

[MEMORY MODEL]

No memory map (only MMIO maps for driver node). No memory sharing
between processes. No fork.

[SYSCALL and IO]

COX user I/O is based on buffered request mechanism, which does not
depend on syscalls anymore. When issue an I/O, user app just writes a
I/O request in the I/O buffer. Notification would come when request
finished. User can also poll the request status by customized
scheduling. The only active syscall is called when the user is blocked
by I/O requests. Thus yield the cpu clock and wait for replies.

[SOCKETS]

I/Os are mainly the socket operations. All IPCs are through the
sockets, local IPCs would be optimized by hardware and
kernel. Currently the network software stack are built in kernel,
leaving drivers in userspace.

[USER BINARY FORMAT]

For a specified arch, the binary of user process should be started by
4 unsigned, ptr-width integer with native byte order, where the
meanings are:

[0] - start, the suggested start address of the binary image.

[1] - entry, indicate the entry code address, where the start
unchanged (same for [2], [3]).

[2] - edata, indicate the end of data address that should copied from
the binary.

[3] - end, indicate the end address of user process, containing the
uninitialized data.

The kernel would change the start address, while keeping the relative
position unchanged. After initialized all data needed, kernel would
pass the control to user process, with a data structure in stack, the
structure is defined and documented in ``include/user/info.h''.
